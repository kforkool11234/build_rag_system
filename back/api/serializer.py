from rest_framework import serializers
from django.contrib.auth.models import User
from ragged.models import UserCollection
from ragged.models import Communication
import uuid
class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ['id', 'username', 'password']

    def create(self, validated_data):
        user = User(
            username=validated_data['username']
        )
        user.set_password(validated_data['password'])  # Hash password
        user.save()
        return user
class CollectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserCollection
        fields = ['id', 'user', 'c_name', 'c_id']
        extra_kwargs = {
            'user': {'read_only': True},
            'c_id': {'read_only': True},  # Prevent client from sending this manually
        }

    def create(self, validated_data):
        user = self.context['request'].user
        c_name = validated_data['c_name']
        unique_id = f"{uuid.uuid4()}_{c_name}"
        return UserCollection.objects.create(user=user, c_name=c_name, c_id=unique_id)
class CommunicationSerializer(serializers.ModelSerializer):
    """
    Serializer for the Communication model (now conceptually 'Collection').

    - 'c_name', 'sender', 'message' are taken directly from request data.
    - 'user' (the recipient user) is automatically set to the authenticated user
      making the request by using serializers.CurrentUserDefault().
      This field is hidden from direct input.
    - 'timestamp' is read-only as it's auto-generated by the model.
    """
    # This field will automatically get the current authenticated user from the request context.
    # It's 'hidden' meaning it won't be expected in the incoming JSON data.
    user = serializers.HiddenField(default=serializers.CurrentUserDefault())

    class Meta:
        model = Communication
        fields = [
            'id',          # Include ID for reference (read-only by default)
            'c_name',
            'sender',
            'message',
            'user',        # Changed from 'recipient_user' to 'user'
            'timestamp'    # Auto-generated by the model, so it's read-only
        ]
        read_only_fields = ['id', 'timestamp'] # Explicitly mark these as read-only

    def validate_user(self, value):
        """
        Custom validation to ensure the 'user' field (recipient) is not None.
        This serializer expects an authenticated user.
        """
        if not value.is_authenticated:
            raise serializers.ValidationError("An authenticated user is required to create a communication.")
        return value

    def to_representation(self, instance):
        """
        Overrides the default representation to include the username of the 'user' field (recipient)
        when sending data back to the client.
        """
        ret = super().to_representation(instance)
        # Add the username of the 'user' (recipient) to the output
        if instance.user:
            ret['username'] = instance.user.username # Changed key name to 'username'
        else:
            ret['username'] = None # Or 'No specific user'
        return ret

